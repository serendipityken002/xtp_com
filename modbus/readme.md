1. 项目流程
- 总结日志管理
  - 大致流程是main文件写了一个自定义的logging.config.dictConfig方法来设置复杂的日志配置（因为这里需要按条件（如日期）滚动日志文件），其他文件logger = logging.getLogger(__name__)，即可调用logger进行info、error等的上传（最终合在主程序定义的文件内）
  - 结果是按天按小时按串口按信息分log
- 缓冲队列
  - 为串口创建一个SerialHandler处理类，定义了收发缓冲队列以及收发线程，也就是每个串口有自己的数据存储，更方便管理。每启动一个串口对应两个线程，在各自的线程内通过self.queue可以调用自己的缓冲队列。
  - 创建一个SerialManager管理类，存储各个 {串口名：串口处理类} 的字典，可根据串口名返回对应的串口处理类，方便后续对各自串口的数据进行读写。
  - 将modbus帧的发送和接收采用缓冲队列存储，队列的每个大小为一个字节，解析时严格按照modbus协议进行读写。为了保证接收队列的长度不能过长，需要隔段时间进行数据帧丢弃。由于接收串口数据回应的线程不能停，他会持续占有接收线程导致丢弃数据与他产生死锁。（这一块还不知道为什么死锁，需要反复斟酌一下）
- TCP协议
  - 基于socket库，创建TCP连接，服务器始终监听预设的ip和端口号，为每一个连接的客户端创建一个进程进行管理
  - 处理客户端请求：客户端会将json格式的内容发送过来，主要解析的还是send和receive指令

2. 遇到的问题：
- 使用串口服务的时候，每一个串口对应了很多个从机，刚开始为了让请求快速发送，将每一个发送请求都建立一个线程实现高并发。但项目使用的modbus485仅支持半双工通信且静默期太短导致设备认为两次请求是同一次发送的。因此采用每个串口设置自己的缓冲队列对发送请求和接收请求进行存储，然后不断的入队出队
- modbus协议返回数据帧时是按字节进行发送的，当接收队列的请求过于频繁的时候会导致同一段数据帧分两次接收。因此采用按字节存储的缓冲队列，并按照modbus协议进行逐字节解析。这也是我刚开始纳闷为什么modbus协议要明确数据帧的长度。
- 若接收队列长时间没有清理会导致内存被持续占用，因此需要定期删除队列的数据帧。这里有一个很大的问题是，为了遵循modbus协议，不能直接删除指定字节长度的内容，还是需要解析数据帧。然后又遇到了一个问题，清理数据帧和接收数据帧请求都需要占用缓冲队列（产生死锁，具体原因不明），因此采用双缓冲队列，一个负责接收数据帧，一个负责处理数据帧（解决办法也就那样，到时候不说吧）
- 由于TCP网络请求不稳定，内网穿透延迟也会导致频繁请求会出现两次json内容连在一起，这里采用json解析

3. 一段话总结本次项目
在串口服务器的项目中，我主要负责设计和实现一个综合性的系统，涵盖日志管理、串口数据处理以及TCP网络通信。首先，在日志管理方面，我们通过定制的日志配置方法实现了按条件滚动存储日志文件的功能，确保了日志信息的有效管理（分时间、分类别）。接着，在串口数据处理部分，我们为每个串口创建了独立的数据缓冲队列和处理线程，有效地解决了高并发请求和Modbus协议下数据帧解析的问题。同时，引入了双缓冲队列机制避免了接收和清理数据时可能出现的死锁问题。最后，在TCP网络通信模块，我们基于socket库建立了稳定的服务器端，能够有效处理客户端发送的JSON格式请求，并解决了由于网络延迟导致的数据粘连问题。
